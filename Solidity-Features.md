This is a list to explain and demonstrate new Solidity features as soon as they are completed.
It is used as a kind of changelog and items introduced at some point might be changed at a later point. The official reference is the [Documentation](http://solidity.readthedocs.org/) which should always reflect the current state of the language.

This page is **not** the official documentation for Solidity. It contains outdated information.

**Do not use example code on this page**

## Events in Exported Interfaces

**This point needs to be added to the Solidity documentation.**

[PT](https://www.pivotaltracker.com/story/show/87036508) Events are exported to the JSON and Solidity interfaces generated by the compiler. The contract
```js
contract c {
    event ev(uint indexed a);
}
```
generates the JSON interface
```js
[
   {
      "inputs" : [
         {
            "indexed" : true,
            "name" : "a",
            "type" : "uint256"
         },
         {
            "indexed" : false,
            "name" : "b",
            "type" : "uint256"
         }
      ],
      "name" : "ev",
      "type" : "event"
   }
]
```
and the Solidity interface
`contract c{event ev(uint256 indexed a,uint256 b);}`.

## SHA3 with arbitrary arguments

**If this is still true (for `keccak256`), we need to add this to the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/86896766). `sha3()` can now take an arbitrary number and type of arguments.
```js
contract c {
  function c()
  {
      val2 = 123;
      val1 = sha3("foo"); // sha3(0x666f6f)
      val3 = sha3(val2, "bar", 1031); //sha3(0x7b6261720407)
  }
  uint256 val1;
  uint16 val2;
  uint256 val3;
}
```

## Inline members initialization

**This point seems to be missing from the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/84982976) Inline members can be initialized at declaration time.
```js
contract test {
  function test(){
    m_b = 6;
  }
  uint m_a = 5;
  uint m_b;
}
```

## Common Subexpression Elimination Excluding Memory and Storage

**Seems to be missing from the official documentation**

[PT](https://www.pivotaltracker.com/story/show/89148380)
The optimizer splits code into blocks (at all operations that have non-local side effects like JUMP, CALL, CREATE and for also all instructions that access or modify memory or storage), analyses these blocks by creating an expression graph and establishes equivalences in a bottom-up way, simplifying expressions that e.g. involve constants. In the following code-generation phase, it re-creates the set of instructions that transform a given initial stack configuration into a given target stack configuration utilizing the simplest representatives of these equivalence classes.
In conjunction with the already present jump-optimization, the two code snippets given below should be compiled into the same sequence of instructions:
```js
contract test {
  function f(uint x, uint y) returns (uint z) {
    var c = x + 3;
    var b = 7 + (c * (8 - 7)) - x;
    return -(-b | 0);
  }
}
```
```js
contract test {
  function f(uint x, uint y) returns (uint z) {
    return 10;
  }
}
```

## Common Subexpression Elimination for Memory and Storage

**Seems to be missing from the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/90785926)
This adds support for memory and storage operations to the common subexpression eliminator. This makes it possible to e.g. stretch the equality inference engine across SSTORE, MSTORE and even SHA3 computations (which go via memory). Without optimizer (because of packed storage), there are 4 SLOAD, 3 SSTORE and 4 SHA3 operations. The optimizer reduces those to a single SLOAD, SHA3 and SSTORE each.
```js
contract test {
  struct s { uint8 a; uint8 b; uint8 c; }
  mapping(uint => s) data;
  function f(uint x, uint8 _a, uint8 _b, uint8 _c) {
    data[x].a = _a;
    data[x].b = _b;
    data[x].c = data[x].a;
  }
}
```

This is a list to explain and demonstrate new Solidity features as soon as they are completed.
It is used as a kind of changelog and items introduced at some point might be changed at a later point. The official reference is the [Documentation](http://solidity.readthedocs.org/) which should always reflect the current state of the language.

This page is **not** the official documentation for Solidity. It contains outdated information.

**Do not use example code on this page**

## Events in Exported Interfaces

**This point needs to be added to the Solidity documentation.**

[PT](https://www.pivotaltracker.com/story/show/87036508) Events are exported to the JSON and Solidity interfaces generated by the compiler. The contract
```js
contract c {
    event ev(uint indexed a);
}
```
generates the JSON interface
```js
[
   {
      "inputs" : [
         {
            "indexed" : true,
            "name" : "a",
            "type" : "uint256"
         },
         {
            "indexed" : false,
            "name" : "b",
            "type" : "uint256"
         }
      ],
      "name" : "ev",
      "type" : "event"
   }
]
```
and the Solidity interface
`contract c{event ev(uint256 indexed a,uint256 b);}`.

## SHA3 with arbitrary arguments

**If this is still true (for `keccak256`), we need to add this to the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/86896766). `sha3()` can now take an arbitrary number and type of arguments.
```js
contract c {
  function c()
  {
      val2 = 123;
      val1 = sha3("foo"); // sha3(0x666f6f)
      val3 = sha3(val2, "bar", 1031); //sha3(0x7b6261720407)
  }
  uint256 val1;
  uint16 val2;
  uint256 val3;
}
```

## Inline members initialization

**This point seems to be missing from the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/84982976) Inline members can be initialized at declaration time.
```js
contract test {
  function test(){
    m_b = 6;
  }
  uint m_a = 5;
  uint m_b;
}
```

## Common Subexpression Elimination Excluding Memory and Storage

**Seems to be missing from the official documentation**

[PT](https://www.pivotaltracker.com/story/show/89148380)
The optimizer splits code into blocks (at all operations that have non-local side effects like JUMP, CALL, CREATE and for also all instructions that access or modify memory or storage), analyses these blocks by creating an expression graph and establishes equivalences in a bottom-up way, simplifying expressions that e.g. involve constants. In the following code-generation phase, it re-creates the set of instructions that transform a given initial stack configuration into a given target stack configuration utilizing the simplest representatives of these equivalence classes.
In conjunction with the already present jump-optimization, the two code snippets given below should be compiled into the same sequence of instructions:
```js
contract test {
  function f(uint x, uint y) returns (uint z) {
    var c = x + 3;
    var b = 7 + (c * (8 - 7)) - x;
    return -(-b | 0);
  }
}
```
```js
contract test {
  function f(uint x, uint y) returns (uint z) {
    return 10;
  }
}
```

## Common Subexpression Elimination for Memory and Storage

**Seems to be missing from the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/90785926)
This adds support for memory and storage operations to the common subexpression eliminator. This makes it possible to e.g. stretch the equality inference engine across SSTORE, MSTORE and even SHA3 computations (which go via memory). Without optimizer (because of packed storage), there are 4 SLOAD, 3 SSTORE and 4 SHA3 operations. The optimizer reduces those to a single SLOAD, SHA3 and SSTORE each.
```js
contract test {
  struct s { uint8 a; uint8 b; uint8 c; }
  mapping(uint => s) data;
  function f(uint x, uint8 _a, uint8 _b, uint8 _c) {
    data[x].a = _a;
    data[x].b = _b;
    data[x].c = data[x].a;
  }
}
```
## External Types

**Yoichi could not find this in the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/88772706)
All functions with visibility more than internal should have external types (ABI types) otherwise raise an error.
For Contract type external type is address type.
```js
contract Foo {}
contract Test {
    function func() {
        Foo arg;
        this.Poo(arg);
        Poo(arg);
    }
    function Poo(Foo c) external {}
}
```
the ABI interface for Poo is Poo(address) when the Solidity interface is still Poo(Foo).

## Overloading Functions

**This seems to be missing from the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/85511572) Contracts can have multiple functions of the same name as long as the parameters differ in number or type. If such an overloaded function is referenced, it has to be called immediately to resolve the ambiguity using the types of the arguments. It is an error if not exactly one of the possible functions can be called with the given arguments.

```js
contract Base {
  function f(uint a) {}
}
contract Derived is Base {
  function f(uint8 b) {}
  function g() {
    // f(250); would create a type error since 250 can be implicitly
    // converted both to a uint8 and to a uint type
    f(2000); // calls f from Base
  }
}
```
Of course overloading a function does not need inheritance, i.e. `f(uint a)` could as well have been defined directly in `Derived`.

Overloaded functions are also present in the external interface. It is an error if two externally visible functions differ by their Solidity types but not by their external types, e.g. `f(Derived _d)` and `f(address _a)` both end up accepting an `address` type for the ABI although they are considered different inside Solidity.

## Merging of Basic Blocks

**Yoichi could not find this in the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/89148124) Blocks of assembly instructions that do not contain jumps, stops or returns are moved and modified according to the following rules:

* if the control never simply flows into a block, but it is jumped to unconditionally, the block is moved, eliminating the jump
* blocks that are never jumped to are removed

These optimizations might sound not very powerful, but together with "Common Subexpression Elimination" (which is does much more than its name might suggest), the following contract is optimized to store `8` in the mapping and return the value without any jump.

```js
contract c {
  function () returns (uint) { return g(8); }
  function g(uint pos) internal returns (uint) { setData(pos, 8); return getData(pos); }
  function setData(uint pos, uint value) internal { data[pos] = value; }
  function getData(uint pos) internal { return data[pos]; }
  mapping(uint => uint) data;
}
```

## Bare Callcode

**Yoichi thinks these descriptions should be ported to the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/94682212) The address type receives a method `callcode` which is similar to `call`, but uses `CALLCODE` instead of `CALL` when the function is invoked. This means that the code at the given address will be executed in the context of the current contract. Example:

```js
contract Code {
  uint m_data;
  function (uint v) { m_data = v; }
}
contract ActualContract {
  uint public m_data;
  function f() { Code(0x12345).callcode(7); }
}
```
Assuming the contract `Code` is deployed at the address `0x12345`, calling `f()` of `ActualContract` will result in `m_data` of `ActualContract` being modified. The user has to ensure that the layout of storage in both contracts is suitable for callcode to be used.

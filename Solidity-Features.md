This is a list to explain and demonstrate new Solidity features as soon as they are completed.
It is used as a kind of changelog and items introduced at some point might be changed at a later point. The official reference is the [Documentation](http://solidity.readthedocs.org/) which should always reflect the current state of the language.

This page is **not** the official documentation for Solidity. It contains outdated information.

**Do not use example code on this page**

## ABI requires arguments to be padded to 32 bytes

**The Solidity compiler does not seem to have this explanation.  It's arguable if this should be ported there.**

[PT](https://www.pivotaltracker.com/story/show/85006670) The latest version of the ABI specification
requires arguments to be padded to multiples of 32 bytes. This is not a language feature that can be demonstrated as code examples. Please see the automated tests `SolidityEndToEndTests::packing_unpacking_types` and `SolidityEndToEndTests::packing_signed_types`.

## Conversion between String and Hash types

**hash types do not exist anymore
 http://solidity.readthedocs.io/en/develop/types.html#explicit-conversions**

[PT](https://www.pivotaltracker.com/story/show/85907772) The explicit conversion between `string` and `hash` types of equal size is now allowed. Example:

```js
contract Test {
  function convert(hash160 h, string20 s) returns (string20 res_s, hash160 res_h) {
    res_s = string20(h);
    res_h = hash160(s);
  }
}
```

## Events in Exported Interfaces

**This point needs to be added to the Solidity documentation.**

[PT](https://www.pivotaltracker.com/story/show/87036508) Events are exported to the JSON and Solidity interfaces generated by the compiler. The contract
```js
contract c {
    event ev(uint indexed a);
}
```
generates the JSON interface
```js
[
   {
      "inputs" : [
         {
            "indexed" : true,
            "name" : "a",
            "type" : "uint256"
         },
         {
            "indexed" : false,
            "name" : "b",
            "type" : "uint256"
         }
      ],
      "name" : "ev",
      "type" : "event"
   }
]
```
and the Solidity interface
`contract c{event ev(uint256 indexed a,uint256 b);}`.

## SHA3 with arbitrary arguments

**If this is still true (for `keccak256`), we need to add this to the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/86896766). `sha3()` can now take an arbitrary number and type of arguments.
```js
contract c {
  function c()
  {
      val2 = 123;
      val1 = sha3("foo"); // sha3(0x666f6f)
      val3 = sha3(val2, "bar", 1031); //sha3(0x7b6261720407)
  }
  uint256 val1;
  uint16 val2;
  uint256 val3;
}
```

## Optional Parameter Names

**Yoichi could not find this in the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/85594334). The names for function parameters and return parameters are now optional.
```js
contract test {
  function func(uint k, uint) returns(uint){
    return k;
  }
}
```

## Inline members initialization

**This point seems to be missing from the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/84982976) Inline members can be initialized at declaration time.
```js
contract test {
  function test(){
    m_b = 6;
  }
  uint m_a = 5;
  uint m_b;
}
```

## Common Subexpression Elimination Excluding Memory and Storage

**Seems to be missing from the official documentation**

[PT](https://www.pivotaltracker.com/story/show/89148380)
The optimizer splits code into blocks (at all operations that have non-local side effects like JUMP, CALL, CREATE and for also all instructions that access or modify memory or storage), analyses these blocks by creating an expression graph and establishes equivalences in a bottom-up way, simplifying expressions that e.g. involve constants. In the following code-generation phase, it re-creates the set of instructions that transform a given initial stack configuration into a given target stack configuration utilizing the simplest representatives of these equivalence classes.
In conjunction with the already present jump-optimization, the two code snippets given below should be compiled into the same sequence of instructions:
```js
contract test {
  function f(uint x, uint y) returns (uint z) {
    var c = x + 3;
    var b = 7 + (c * (8 - 7)) - x;
    return -(-b | 0);
  }
}
```
```js
contract test {
  function f(uint x, uint y) returns (uint z) {
    return 10;
  }
}
```

## Common Subexpression Elimination for Memory and Storage

**Seems to be missing from the official documentation.**

[PT](https://www.pivotaltracker.com/story/show/90785926)
This adds support for memory and storage operations to the common subexpression eliminator. This makes it possible to e.g. stretch the equality inference engine across SSTORE, MSTORE and even SHA3 computations (which go via memory). Without optimizer (because of packed storage), there are 4 SLOAD, 3 SSTORE and 4 SHA3 operations. The optimizer reduces those to a single SLOAD, SHA3 and SSTORE each.
```js
contract test {
  struct s { uint8 a; uint8 b; uint8 c; }
  mapping(uint => s) data;
  function f(uint x, uint8 _a, uint8 _b, uint8 _c) {
    data[x].a = _a;
    data[x].b = _b;
    data[x].c = data[x].a;
  }
}
```
## External Types
[PT](https://www.pivotaltracker.com/story/show/88772706)
All functions with visibility more than internal should have external types (ABI types) otherwise raise an error.
For Contract type external type is address type.
```js
contract Foo {}
contract Test {
    function func() {
        Foo arg;
        this.Poo(arg);
        Poo(arg);
    }
    function Poo(Foo c) external {}
}
```
the ABI interface for Poo is Poo(address) when the Solidity interface is still Poo(Foo).

## Accessor for Arrays
[PT](https://www.pivotaltracker.com/story/show/88500646)
For Arrays the accessor is generated which accepts the index as parameter and returns an array element
```js
contract test {
    uint[3] public data;
    function test() {
        data[0] = 0;
        data[1] = 1;
        data[2] = 2;
    }
}
```
In the above contract if you tried to call the data(1) method of the test you would obtain the result 1.

## Overloading Functions
[PT](https://www.pivotaltracker.com/story/show/85511572) Contracts can have multiple functions of the same name as long as the parameters differ in number or type. If such an overloaded function is referenced, it has to be called immediately to resolve the ambiguity using the types of the arguments. It is an error if not exactly one of the possible functions can be called with the given arguments.

```js
contract Base {
  function f(uint a) {}
}
contract Derived is Base {
  function f(uint8 b) {}
  function g() {
    // f(250); would create a type error since 250 can be implicitly
    // converted both to a uint8 and to a uint type
    f(2000); // calls f from Base
  }
}
```
Of course overloading a function does not need inheritance, i.e. `f(uint a)` could as well have been defined directly in `Derived`.

Overloaded functions are also present in the external interface. It is an error if two externally visible functions differ by their Solidity types but not by their external types, e.g. `f(Derived _d)` and `f(address _a)` both end up accepting an `address` type for the ABI although they are considered different inside Solidity.

## Merging of Basic Blocks
[PT](https://www.pivotaltracker.com/story/show/89148124) Blocks of assembly instructions that do not contain jumps, stops or returns are moved and modified according to the following rules:

* if the control never simply flows into a block, but it is jumped to unconditionally, the block is moved, eliminating the jump
* blocks that are never jumped to are removed

These optimizations might sound not very powerful, but together with "Common Subexpression Elimination" (which is does much more than its name might suggest), the following contract is optimized to store `8` in the mapping and return the value without any jump.

```js
contract c {
  function () returns (uint) { return g(8); }
  function g(uint pos) internal returns (uint) { setData(pos, 8); return getData(pos); }
  function setData(uint pos, uint value) internal { data[pos] = value; }
  function getData(uint pos) internal { return data[pos]; }
  mapping(uint => uint) data;
}
```

## Interface contracts

[PT](https://www.pivotaltracker.com/story/show/88344782) Contracts can be marked as "not fully implemented" by containing at least one abstract function. A function is abstract if it does not have a body defined.

```js
contract base { function foo(); }
contract derived is base { function foo() {} }
```

For example in the above, foo is an abstract function and as such the base contract is an interface contract. All non-interface contracts that derive from it must implement its abstract functions.

## Bare Callcode

[PT](https://www.pivotaltracker.com/story/show/94682212) The address type receives a method `callcode` which is similar to `call`, but uses `CALLCODE` instead of `CALL` when the function is invoked. This means that the code at the given address will be executed in the context of the current contract. Example:

```js
contract Code {
  uint m_data;
  function (uint v) { m_data = v; }
}
contract ActualContract {
  uint public m_data;
  function f() { Code(0x12345).callcode(7); }
}
```
Assuming the contract `Code` is deployed at the address `0x12345`, calling `f()` of `ActualContract` will result in `m_data` of `ActualContract` being modified. The user has to ensure that the layout of storage in both contracts is suitable for callcode to be used.

## Gas Estimation

[PT](https://www.pivotaltracker.com/story/show/90098268) Solidity provides two ways to compute an upper bound on the gas usage of code: A structural one, which can be used to identify expensive statements and a functional one which tries to give an exact gas estimation for each function.
Some gas costs depend on the state of the virtual machine, e.g. on the cost of `sha3` depends on the length of the argument and writing to storage has different costs depending on whether the storage slot had the value zero or not.

For the structural gas estimation, the gas cost of each opcode is computed assuming the intersection of all states in which the VM could reach this opcode. These costs are accumulated for each opcode that results from a specific statement (in some situations also other AST nodes) in the AST. So in this mode, opcodes are not counted multiple times even if they occur in loops.

The functional gas estimation takes a different approach: For each function in a contract, the execution of this function is "simulated". As we want to provide an upper bound on the gas costs independent of the actual arguments, this is sometimes not accurate and may even result in "infinite" gas costs. Note that the gas costs of message-called functions are not included in the gas costs of a function.

## Re-introduce string type

[PT](https://www.pivotaltracker.com/story/show/95173586)
`string` is added as a type which behaves exactly like `bytes` with the following differences:
 - index access is not allowed
 - it does not have a length member

In the ABI encoding (wiki already changed), string is a dynamic type whose "number of elements" field is the number of bytes, not the number of characters.
The encoding of the string is assumed to be UTF-8, but is not yet used inside Solidity.

## In-memory types

[PT](https://www.pivotaltracker.com/n/projects/1189488/stories/88238440)
Variables of reference type (structs and arrays including `string` and `bytes`) can either point to memory, storage or calldata. The keywords `storage` and `memory` as part of their declaration are used to indicate that (calldata cannot be used explicitly). Parameters (not return parameters) of external functions are forced to point to calldata. Parameters (also return parameters) of public and return parameters of external functions are forced to point to memory. In all other cases, if neither storage nor memory is given, function parameters default to point to memory and local variables default to point to storage.

Note that this story enforces the constraints on memory-stored structs, but does not yet fully implement the code-generation part. Arrays, on the other hand, are fully implemented.

As part of this change, references to storage are also cleaned up: An assignment of a state variable to a local variable or temporary converts it from a reference to a pointer. Assignments to storage pointers do not modify storage but only change the pointer. This means that it is not possible to assign a memory array to a storage pointer. Furthermore, it is illegal to pass a memory-array as an argument to a function that requires a storage reference (note that storage is statically allocated, i.e. there is no place to put this value). Es an example:
```js
contract c {
  uint[] x;
  function f(uint[] memoryArray) {
    x = memoryArray; // works, copies the array to storage
    var y = x; // works, assigns a pointer
    y[7]; // fine, returns the 8th element
    y.length = 2; // fine, modifies storage
    delete x; // fine, clears the array
    // y = memoryArray; // does not work, would need to create a new temporary / unnamed array in storage, but storage is "statically" allocated
    // delete y; // does not work, would set pointer to zero and does not make sense for pointer
  }
}
```

If possible (i.e. from anything to memory and from anything to a storage reference that is not a pointer), conversions between these data locations are performed automatically by the compiler. Sometimes, this is still not possible, i.e. mappings cannot reside in memory (as their size is unknown) and for now, some types in memory are not yet implemented, this includes structs and multi-dimensional arrays.

Of course, once a storage array is converted to memory, modifications do not affect the array in storage. You can either assign the modified array back to storage (though this would be vastly inefficient) or you can pass around a storage pointer to begin with. As an example:

```js
contract BinarySearch {
  /// Finds the position of _value in the sorted list _data.
  /// Note that "internal" is important here, because storage references only work for internal or private functions
  function find(uint[] storage _data, uint _value) internal returns (uint o_position) {
    return find(_data, 0, _data.length, _value);
  }
  function find(uint[] storage _data, uint _begin, uint _len, uint _value) private returns (uint o_position) {
    if (_len == 0 || (_len == 1 && _data[_begin] != _value))
      return uint(-1); // failure
    uint halfLen = _len / 2;
    uint v = _data[_begin + halfLen];
    if (_value < v)
      return find(_data, _begin, halfLen, _value);
    else if (_value > v)
      return find(_data, _begin + halfLen + 1, halfLen - 1, _value);
    else
      return _begin + halfLen;
  }
}
```


On memory usage: Since memory is wiped after each external function call, the Solidity runtime does not include proper memory management. It includes a "level indicator" which points to the next free memory slot. If memory is needed (because a storage object is copied to memory or an external function is called), it is allocated starting from this pointer. Functions that return objects stored in memory will not reset this pointer. This means that temporary memory objects will still take up space in memory even if they are not needed anymore. On the other hand, if a function does not return any memory-stored object, it resets the pointer to the value it had upon function entry (this is not yet implemented).

The EVM does not allow `CALL` to be used with variably-sized return values. Because of this, return types of message-called functions which are dynamically sized are transparently changed to `void`. Clearing up the confusion which might arise in face of the resulting error message remains to do.

Memory-stored objects as local variables are correctly zero-initialised: Members of structs and elements of fixed-size arrays are recursively initialised, dynamic arrays are set to zero length. `delete x` assigns a new zero-initialised value to `x`.

## Positive integers conversion to signed

[PT](https://www.pivotaltracker.com/n/projects/1189488/stories/92691082)
Positive integer literals are now convertible to signed if in value range.
```js
int8 x = 2;
```

## Exceptions in Solidity

[PT](https://www.pivotaltracker.com/n/projects/1189488/stories/92929256)
Currently, there are two situations, where exceptions can happen in Solidity: If you access an array beyond its length (i.e. x[i] where i >= x.length) or if a function called via a message call does not finish properly (i.e. it runs out of gas or throws an exception itself). In such cases, Solidity will trigger an "invalid jump" and thus cause the EVM to revert all changes made to the state.

It is planned to also throw and catch exceptions manually.

## Structs in Memory

[PT](https://www.pivotaltracker.com/n/projects/1189488/stories/84119690)
Structs can be passed around as function arguments, be returned from functions
and created in memory.

```js
contract C {
    struct S { uint a; uint b; }
    struct A { uint x; uint y; S s; }
    A data;
    function f() internal returns (A) {
        // Construct structs inline, pass to a function and return from it.
        // Memory is allocated only once, pointers are passed around.
        // Construction by member name is possible.
        return g(A(5, 7, S({b: 1, a: 2})));
    }
    function g(A _a) internal returns (A) {
        _a.s.b = 2;
        data = _a; // performs a copy
        return _a;
    }
}
```

## Flexible String Literals

[PT](https://www.pivotaltracker.com/n/projects/1189488/stories/98462528)
String literals can be implicitly converted to `bytesX` (if they are not too long),
`string` and `bytes`, especially, they can be much longer than 32 bytes.

```js
contract C {
  bytes32 x;
  function greet() returns (string) {
    x = "Hello, World!";
    return "Hello, World!";
  }
}
```

## Strings as Mapping Keys

Strings are allowed as keys for mappings.
```js
contract C {
  mapping (string => uint) counter;
  function inc(string _s) { counter[_s]++; }
}
```

## Libraries (without inheritance)

[PT](https://www.pivotaltracker.com/n/projects/1189488/stories/82180360)

Libraries are similar to contracts, but their purpose is that they are deployed only once at a specific address and their functions are called using CALLCODE, i.e. the library's code is called in the context of the calling contract.

```js
library Math {
  function max(uint a, uint b) returns (uint) {
    if (a > b) return a;
    else return b;
  }
  function min(uint a, uint b) returns (uint) {
    if (a < b) return a;
    else return b;
  }
}
contract C {
  function register(uint value) {
    value = Math.max(10, Math.min(100, value)); // clamp value to [10, 100]
    // ...
  }
}
```

The calls to `Math.max` and `Math.min` are both compiled as calls (CALLCODEs) to an external contract. as the compiler cannot know where the library will be deployed at, these addresses have to be filled into the final bytecode by a linker. If the addresses are not given as arguments to the compiler, the compiled hex code will contain placeholders of the form `__Math______` (where `Math` is the name of the library). The address can be filled manually by replacing all those 40 symbols by the hex encoding of the address of the library contract.

Restrictions for libraries in comparison to contracts:
 - no state variables
 - cannot inherit nor be inherited

(these might be lifted at a later point)

How to use the commandline compiler to link binaries:

New option `--libraries` to either give a file containing the library addresses or directly as a string (tries to open as a file). Syntax: `<libraryName>: <address> [, or Whitespace] ...`
The address is a hex string that is optionally prefixed with `0x`.

If solc is called with the option `--link`, all input files are interpreted to be unlinked binaries (hex-encoded) and are linked in-place (if the input is read from stdin, it is written to stdout).
All options except `--libraries` are ignored (including `-o`).

## Throw

[PT](https://www.pivotaltracker.com/story/show/96275370)

throw is a statement that triggers a solidity exception and thus can be used to revert changes made during the transaction. It does not take any parameters and jumps to the error tag.
```js
contract Sharer {
    function sendHalf(address addr) returns (uint balance) {
        if (!addr.send(msg.value/2))
            throw; // also reverts the transfer to Sharer
        return address(this).balance;
    }
}
```

## Tightly Stored Byte Arrays and Strings

[PT](https://www.pivotaltracker.com/story/show/101758652)

Byte arrays (`bytes`) and strings (`string`) are stored more tightly packed in storage:
Short values (less than 32 bytes) are stored directly together with the length:
`<value><length * 2>` (the 31 higher-significant bytes contain the value, the least significant byte contains the doubled length)
Long values (at least 32 bytes) are stored as they were stored before, just that the length is doubled and the least significant bit is set to one to indicate "long string".

Example: "abcdef" is stored as `0x61626364656600000...000d` while `"abcabcabc....abc"` (of length 40) is stored as `0x0000000...0051` in the main slot, and `616263616263...` is stored in the data slots.

## Internal Types for Libraries

[PT](https://www.pivotaltracker.com/story/show/101774798) Storage reference types are allowed to be passed to library functions. Together with this change, it is now possible to access internal types of other contracts and libraries and a compiler version stamp is added at the beginning of library runtime code.

Example:

```js
/// @dev Models a modifiable and iterable set of uint values.
library IntegerSet
{
  struct data
  {
    /// Mapping item => index (or zero if not present)
    mapping(uint => uint) index;
    /// Items by index (index 0 is invalid), items with index[item] == 0 are invalid.
    uint[] items;
    /// Number of stored items.
    uint size;
  }
  function insert(data storage self, uint value) returns (bool alreadyPresent)
  {
    uint index = self.index[value];
    if (index > 0)
      return true;
    else
    {
      if (self.items.length == 0) self.items.length = 1;
      index = self.items.length++;
      self.items[index] = value;
      self.index[value] = index;
      self.size++;
      return false;
    }
  }
  function remove(data storage self, uint value) returns (bool success)
  {
    uint index = self.index[value];
    if (index == 0)
      return false;
    delete self.index[value];
    delete self.items[index];
    self.size --;
  }
  function contains(data storage self, uint value) returns (bool)
  {
    return self.index[value] > 0;
  }
  function iterate_start(data storage self) returns (uint index)
  {
    return iterate_advance(self, 0);
  }
  function iterate_valid(data storage self, uint index) returns (bool)
  {
    return index < self.items.length;
  }
  function iterate_advance(data storage self, uint index) returns (uint r_index)
  {
    index++;
    while (iterate_valid(self, index) && self.index[self.items[index]] == index)
      index++;
    return index;
  }
  function iterate_get(data storage self, uint index) returns (uint value)
  {
      return self.items[index];
  }
}

/// How to use it:
contract User
{
  /// Just a struct holding our data.
  IntegerSet.data data;
  /// Insert something
  function insert(uint v) returns (uint size)
  {
    /// Sends `data` via reference, so IntegerSet can modify it.
    IntegerSet.insert(data, v);
    /// We can access members of the struct - but we should take care not to mess with them.
    return data.size;
  }
  /// Computes the sum of all stored data.
  function sum() returns (uint s)
  {
    for (var i = IntegerSet.iterate_start(data); IntegerSet.iterate_valid(data, i); i = IntegerSet.iterate_advance(data, i))
      s += IntegerSet.iterate_get(data, i);
  }
}
```

## Destructuring Assignments

[PT](https://www.pivotaltracker.com/story/show/99085194) Inline tuples can be created and assigned to newly declared local variables or already existing lvalues. This makes it possible to access multiple return values from functions.

``` function f() returns (uint, uint, uint) { return (1,2,3); }```
```js
var (a,b,c) = f();
var (,x,) = f();
var (,y) = f();
var (z,) = f();
```
For newly declared variables it is not possible to specify the types of variables, they will be inferred from the assigned value. Any component in the assigned tuple can be left out. If the first or last element is left out, they can consume an arbitrary number of values. At the end of this code, we will have:
`a == 1`, `b == 2`, `c == 3`, `x == 2`, `y == 3`, `z == 1`.

For newly constructed tuples, elements may not be left out, except for one special case that allows to distiguish between 1-tuples and single expressions: `(x)` is equivalent to `x`, but `(x,)` is a 1-tuple containing `x`.

Assigning to pre-existing lvalues is similar to declaring multiple variables and also allows wildcards:

```js
contract c {
  string s;
  struct Data {uint a; uint b;}
  mapping(uint => Data) data;
  function f() {
    (s, data[45]) = ("abc", Data(1, 2));
  }
}
```

## `.push()` for Dynamic Storage Arrays

[PT](https://www.pivotaltracker.com/story/show/105439966) Dynamically-sized storage arrays have a member function `push`, such that
`var l = arr.push(el);` is equivalent to `arr[arr.length++] = el; var l = arr.length;`.

```js
contract c {
  struct Account { address owner; uint balance; }
  Account[] accounts;
  function newAccount(address _owner, uint _balance) {
    accounts.push(Account(_owner, _balance));
  }
}
```

## Allocation of Dynamic Memory Arrays

[PT](https://www.pivotaltracker.com/story/show/101688050) Dynamic memory arrays can be allocated in the following way:

```js
contract c {
  function f() {
    uint[] memory x = new uint[](100);
    uint[][] memory twoDim = new uint[][](20);
    for (uint i = 0; i < twoDim.length; i++)
      twoDim[i] = new uint[](30);
  }
}
```

This is a **breaking change** because of the way NewExpressions are parsed: Expressions of the form
`new ContractName.value(10)()` have to be changed to `(new ContractName).value(10)()`.

## Support for addmod and mulmod

[PT](https://www.pivotaltracker.com/story/show/108433524) Modular arithmetics outside of the 256 bit field is provided by the `addmod` and `mulmod` functions. `addmod(x, y, z)` computes `(x+y) % z`, only that it uses unbounded integers for the computations. Similarly, `mulmod(x, y, z)` computes `(x*y) % z`.

## Attaching Library Functions to Types

[PT](https://www.pivotaltracker.com/story/show/101773928) At the contract level, statements of the form `using Lib for Type;` are possible, where `Lib` has to be the name of a library and `Type` can either be the name of a type or `*`. The effect is that all functions in `Lib` are attached to variables of type `Type` (or just all, if `Y` is `*`) as member functions and expressions of the form `x.function(a, b)` are essentially equivalent to `Lib.function(x, a, b)`.

```js
library Lib {
  function sum(uint[] storage self) returns (uint s) {
    for (uint i = 0; i < self.length; i++)
      s += self[i];
  }
}
contract C {
  using Lib for uint[];
  uint[] data;
  function f() {
    data.push(data.sum());
  }
}
```

## More Flexible Import

[PT](https://www.pivotaltracker.com/story/show/102848776) The import statement will behave as a subset of the [ES6 import](http://exploringjs.com/es6/ch_modules.html). The `export` keyword is not available, all symbols will be exported and there is no "default export". The import statement behaves as follows:

`import "filename";`: will import all symbols from `"filename"` (and symbols imported there) into the current global scope (different than in ES6 but backwards-compatible for Solidity).

`import * as symbolName from "filename";` creates a new global symbol `symbolName` whose members are all symbols from `"filename"`.

`import {symbol1 as alias, symbol2} from "filename";` creates new global symbols `alias` and `symbol2` which reference `symbol1` and `symbal2` from `"filename"`, respectively.

Another syntax that is not part of ES6, but probably convenient:

`import "filename" as symbolName;` is equivalent to `import * as symbolName from "filename";`.

### Path Resolution

In the above, `filename` is always treated as a path to a file with `/` as directory separator, `.` as the current directory and `..` as the parent directory. Path names that do not start with `./` or `../` are treated as absolute paths and the compiler has to be instructed how to resolve the first element of that path. Using `.` or `..` is only valid at the beginning of the path. This hierarchy does not need to strictly map onto the filesystem, it can also map to resources discovered via e.g. ipfs, http or git.

When the compiler is invoked, it is not only possible to specify how to discover the first element of a path, but it is possible to specify path prefix remappings so that e.g. `github.com/ethereum/dapp-bin/library` is remapped to `/usr/local/dapp-bin/library` and the compiler will read the files from there. If remapping keys are prefixes of each other, the longest is tried first. This allows for a "fallback-remapping" with e.g. "" maps to "/usr/local/include/solidity".

### Changes to solc Interface

For solc, these remappings are provided as `key=value` arguments, where the `=value` part is optional (and defaults to `key` in that case). All remapping values that are regular files are compiled (including their dependencies). This mechanism is completely backwards-compatible (as long as no filename contains a `=`) and thus not a breaking change. solc will only read files in directory(ies) where input files reside or in remapping targets.

## Index access for fixed bytes type

[PT](https://www.pivotaltracker.com/story/show/108246592) Single bytes of expressions of type `bytes8`, ..., `bytes32` are accessible using `[i]`. Example:

```js
contract C {
  function f(bytes32 a, uint i) returns (byte) { return a[i]; }
}
```

Write access is not supported, as it is actually quite difficult and blurs the distinction between value and reference types.

## Inline Assembly

[PT](https://www.pivotaltracker.com/story/show/103578058) Allow the use of EVM opcodes (and more) at any point where statements are allowed in Solidity. Full documentation with examples can be found in the official documentation. Small example:

```js
contract C {
    function fib() {
	assembly {
		let n := calldataload(4)
		let a := 1
		let b := a
	loop:
		jumpi(loopend, eq(n, 0))
		a add swap1
		n := sub(n, 1)
		jump(loop)
	loopend:
		mstore(0, a)
		return(0, 0x20)
	}
    }
}
```

## Calling Internal Functions of Libraries

Internal functions of libraries can now be called in the same way as internal functions of
base classes can be called. This has the effect that the code of the library function
is pulled into the assembly / binary of the caller, i.e. it does not generate an actual EVM call.

Examples and more detailed documentation can be found in the [documentation](http://solidity.readthedocs.io/en/latest/contracts.html#libraries).